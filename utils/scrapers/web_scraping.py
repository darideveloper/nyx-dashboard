import os
import time
import zipfile
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import Select
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.remote.webelement import WebElement

current_file = os.path.basename(__file__)


class WebScraping ():
    """ Class to manage and configure web browser
    """
    
    service = None
    options = None

    def __init__(self, headless: bool = False, time_out: int = 0,
                 proxy_server: str = "", proxy_port: str = "",
                 proxy_user: str = "", proxy_pass: str = "",
                 chrome_folder: str = "", user_agent: str = "",
                 download_folder: str = "", extensions: list = [],
                 incognito: bool = False, experimentals: bool = True,
                 start_killing: bool = False, start_openning: bool = True,
                 width: int = 1280, height: int = 720,
                 mute: bool = True, auto_chrome_folder_windows: bool = False):
        
        """ Save settings and create a new instance of the web browser

        Args:
            headless (bool, optional): Hide (True) or show Chrome. Defaults to False.
            time_out (int, optional): Wait time to load each page. Defaults to 0.
            proxy_server (str, optional): Proxy server or host to use. Defaults to "".
            proxy_port (str, optional): Proxy post to use in the window. Defaults to "".
            proxy_user (str, optional): Proxy user to use in the window. Defaults to "".
            proxy_pass (str, optional): Proxy password to use. Defaults to "".
            chrome_folder (str, optional): folder with user chrome data. Defaults to "".
            user_agent (str, optional): user agent value to use. Defaults to False.
            download_folder (str, optional): Default download folder. Defaults to "".
            extensions (list, optional): Paths of .crx extensions. Defaults to [].
            incognito (bool, optional): Open chrome in incognito mode. Defaults to False.
            experimentals (bool, optional): Activate the experimentals. Defaults to True.
            start_killing (bool, optional): Kill chrome when starts. Defaults to False.
            start_openning (bool, optional): Open chrome before starts. Defaults to True.
            width (int, optional): Width of the window. Defaults to 1280.
            height (int, optional): Height of the window. Defaults to 720.
            mute (bool, optional): Mute the audio of the window. Defaults to True.
        """

        self.basetime = 1

        # variables of class
        self.current_folder = os.path.dirname(__file__)
        self.__headless__ = headless
        self.__proxy_server__ = proxy_server
        self.__proxy_port__ = proxy_port
        self.__proxy_user__ = proxy_user
        self.__proxy_pass__ = proxy_pass
        self.__pluginfile__ = os.path.join(self.current_folder, 'proxy_auth_plugin.zip')
        self.__chrome_folder__ = chrome_folder
        self.__user_agent__ = user_agent
        self.__download_folder__ = download_folder
        self.__extensions__ = extensions
        self.__incognito__ = incognito
        self.__experimentals__ = experimentals
        self.__start_openning__ = start_openning
        self.__width__ = width
        self.__height__ = height
        self.__mute__ = mute
        
        self.__web_page__ = None
        
        # Fix chrome folder
        if auto_chrome_folder_windows:
            username = os.getlogin()
            self.__chrome_folder__ = f"C:\\Users\\{username}\\AppData"
            self.__chrome_folder__ += "\\Local\\Google\\Chrome\\User Data"

        # Kill chrome from terminal
        if start_killing:
            windows = 'taskkill /IM "chrome.exe" /F > nul 2>&1'
            linux = "pkill -9 -f chrome > /dev/null 2>&1"
            
            if os.name == "nt":
                os.system(windows)
            else:
                os.system(linux)
            
        # Create and instance of the web browser
        if self.__start_openning__:
            self.__set_browser_instance__()

        # Get current file name
        self.current_file = os.path.basename(__file__)

        # Set time out
        if time_out > 0:
            self.driver.set_page_load_timeout(time_out)

    def set_cookies(self, cookies: list):
        """ Get list of cookies, formatted, from 'cookies.json' file

        Args:
            cookies (list): cookies generated by 'EditThisCookie' extension
        """

        # Format cookies
        cookies_formatted = []
        for cookie in cookies:

            # rename expiration date
            if "expirationDate" in cookie:
                cookie["expiry"] = int(cookie["expirationDate"])
                del cookie["expirationDate"]

            cookies_formatted.append(cookie)

        for cookie in cookies_formatted:
            try:
                self.driver.add_cookie(cookie)
            except Exception:
                pass

    def __set_browser_instance__(self):
        """ Open and configure browser
        """

        # Disable logs
        os.environ['WDM_LOG_LEVEL'] = '0'
        os.environ['WDM_PRINT_FIRST_LINE'] = 'False'

        # Configure browser
        if not WebScraping.options:
            WebScraping.options = webdriver.ChromeOptions()
            options_elems = [
                '--no-sandbox',
                '--start-maximized',
                '--output=/dev/null',
                '--log-level=3',
                '--disable-notifications',
                '--disable-infobars',
                '--safebrowsing-disable-download-protection',
                '--disable-dev-shm-usage',
                '--disable-renderer-backgrounding',
                '--disable-background-timer-throttling',
                '--disable-backgrounding-occluded-windows',
                '--disable-client-side-phishing-detection',
                '--disable-crash-reporter',
                '--disable-oopr-debug-crash-dump',
                '--no-crash-upload',
                '--disable-gpu',
                '--disable-extensions',
                '--disable-low-res-tiling',
                '--silent'
            ]
            
            for option in options_elems:
                WebScraping.options.add_argument(option)
            
            # Experimentals
            if self.__experimentals__:
                WebScraping.options.add_experimental_option(
                    'excludeSwitches', ['enable-logging', "enable-automation"])
                WebScraping.options.add_experimental_option(
                    'useAutomationExtension',
                    False
                )

            # screen size
            size_option = f"--window-size={self.__width__},{self.__height__}"
            WebScraping.options.add_argument(size_option)
            
            # headless mode
            if self.__headless__:
                WebScraping.options.add_argument("--headless=new")
                
            if self.__mute__:
                WebScraping.options.add_argument("--mute-audio")
                
            # Set chrome folder
            if self.__chrome_folder__:
                chrome_folder_option = f"--user-data-dir={self.__chrome_folder__}"
                WebScraping.options.add_argument(chrome_folder_option)

            # Set default user agent
            if self.__user_agent__:
                WebScraping.options.add_argument(f'--user-agent={self.__user_agent__}')

            if self.__download_folder__:
                prefs = {
                    'download.default_directory': f'{self.__download_folder__}',
                    'download.prompt_for_download': 'false',
                    'profile.default_content_setting_values.automatic_downloads': 1,
                    'profile.default_content_settings.popups': 0,
                    'download.directory_upgrade': True,
                    'plugins.always_open_pdf_externally': True,
                    'plugins.plugins_list': [
                        {
                            'enabled': False,
                            'name': 'Chrome PDF Viewer'
                        }
                    ],
                    'download.extensions_to_open': 'xml',
                    'safebrowsing.enabled': True
                }

                WebScraping.options.add_experimental_option('prefs', prefs)

            if self.__extensions__:
                for extension in self.__extensions__:
                    WebScraping.options.add_extension(extension)

            if self.__incognito__:
                WebScraping.options.add_argument("--incognito")

            if self.__experimentals__:
                WebScraping.options.add_argument(
                    "--disable-blink-features=AutomationControlled"
                )
        
        # Setup proxy
        if self.__proxy_server__ and self.__proxy_port__:
            
            # Setup user and password proxy
            if self.__proxy_user__ and self.__proxy_pass__:
                self.__create_proxy_extension__()
                WebScraping.options.add_extension(self.__pluginfile__)
                
            # Setup basic proxy
            else:
                proxy = f"{self.__proxy_server__}:{self.__proxy_port__}"
                WebScraping.options.add_argument(f"--proxy-server={proxy}")

        # Autoinstall driver with selenium
        if not WebScraping.service:
            WebScraping.service = Service()
          
        # Auto download driver
        self.driver = webdriver.Chrome(
            service=WebScraping.service,
            options=WebScraping.options
        )

    def __create_proxy_extesion__(self):
        """ Create a proxy chrome extension """

        # plugin data
        manifest_json = f"""
        {
            "version": "1.0.0",
            "manifest_version": 2,
            "name": "Chrome Proxy",
            "permissions": [
                "proxy",
                "tabs",
                "unlimitedStorage",
                "storage",
                "<all_urls>",
                "webRequest",
                "webRequestBlocking"
            ],
            "background": {
                "scripts": ["background.js"]
            },
            "minimum_chrome_version":"22.0.0"
        }
        """

        background_js = """
        var config = {
                mode: "fixed_servers",
                rules: {
                singleProxy: {
                    scheme: "http",
                    host: "%s",
                    port: parseInt(%s)
                },
                bypassList: ["localhost"]
                }
            };

        chrome.proxy.settings.set({value: config, scope: "regular"}, function() {});

        function callbackFn(details) {
            return {
                authCredentials: {
                    username: "%s",
                    password: "%s"
                }
            };
        }

        chrome.webRequest.onAuthRequired.addListener(
                    callbackFn,
                    {urls: ["<all_urls>"]},
                    ['blocking']
        );
        """ % (self.__proxy_server__, self.__proxy_port__,
               self.__proxy_user__, self.__proxy_pass__)

        # Compress file
        with zipfile.ZipFile(self.__pluginfile__, 'w') as zp:
            zp.writestr("manifest.json", manifest_json)
            zp.writestr("background.js", background_js)

    def screenshot(self, base_name: str):
        """ Take a sreenshot of the current browser window
        
        Args:
            base_name (str): base name of the screenshot png image
        """

        if str(base_name).endswith(".png"):
            file_name = base_name
        else:
            file_name = f"{base_name}.png"

        self.driver.save_screenshot(file_name)

    def full_screenshot(self, path: str):
        """ Take a full screenshot of the current browser window

        Args:
            path (str): path to save the screenshot
        """

        original_size = self.driver.get_window_size()
        required_width = self.driver.execute_script(
            'return document.body.parentNode.scrollWidth')
        required_height = self.driver.execute_script(
            'return document.body.parentNode.scrollHeight')
        self.driver.set_window_size(required_width, required_height)
        # driver.save_screenshot(path)  # has scrollbar
        self.screenshot(path)  # avoids scrollbar
        self.driver.set_window_size(
            original_size['width'], original_size['height'])

    def get_browser(self) -> webdriver:
        """ Return the current instance of web browser
        
        Returns:
            webdriver: instance of web browser
        """

        return self.driver

    def end_browser(self):
        """ End current instance of web browser
        """

        self.driver.quit()

    def __reload_browser__(self):
        """ Close the current instance of the web browser and reload in the same page
        """

        self.end_browser()
        self.driver = self.get_browser()
        self.driver.get(self.__web_page__)

    def send_data(self, selector: str, data: str):
        """ Send data to specific input fill
        
        Args:
            selector (str): CSS selector of the input
            data (str): data to send to the input
        """

        elem = self.driver.find_element(By.CSS_SELECTOR, selector)
        elem.send_keys(data)

    def click(self, selector: str):
        """ Send click to specific element in the page
        
        Args:
            selector (str): CSS selector of the element
        """

        elem = self.driver.find_element(By.CSS_SELECTOR, selector)
        elem.click()

    def wait_load(self, selector: str, time_out: int = 10, refresh_back_tab: int = -1):
        """ Wait to page load an element
        
        Args
            selector (str): CSS selector of the element
            time_out (int): time to wait
            refresh_back_tab (int): tab to return after refresh
        """

        total_time = 0

        while True:
            if total_time < time_out:
                total_time += 1
                try:
                    elem = self.driver.find_element(By.CSS_SELECTOR, selector)
                    elem.text
                    break
                except Exception:

                    # Wait time or refresh page
                    if refresh_back_tab != -1:
                        self.refresh_selenium(back_tab=refresh_back_tab)
                    else:
                        time.sleep(self.basetime)

                    continue
            else:
                error = f"Time out exeded. The element {selector} is not in the page"
                raise Exception(error)

    def wait_die(self, selector: str, time_out: int = 10):
        """ Wait to page vanish and element
        
        Args:
            selector (str): CSS selector of the element
            time_out (int): time to wait
        """

        self.refresh_selenium()

        total_time = 0

        while True:
            if total_time < time_out:
                total_time += 1
                elem = self.get_elems(selector)
                if not elem:
                    break
                self.refresh_selenium()
                continue
            else:
                error = f"Time out exeded. The element {selector} is until in the page"
                raise Exception(error)
            
        self.refresh_selenium()

    def get_text(self, selector: str) -> str:
        """ Return text for specific element in the page
        
        Args:
            selector (str): CSS selector of the element
            
        Returns:
            str: text of the element
        """

        try:
            elem = self.driver.find_element(By.CSS_SELECTOR, selector)
            return elem.text
        except Exception:
            # print (err)
            return ""

    def get_texts(self, selector: str) -> list:
        """ Return a list of text for specific selector
        
        Args:
            selector (str): CSS selector of the elements
            
        Returns:
            list: list of texts
        """

        texts = []

        elems = self.driver.find_elements(By.CSS_SELECTOR, selector)

        for elem in elems:
            try:
                texts.append(elem.text)
            except Exception:
                continue

        return texts

    def set_attrib(self, selector: str, attrib_name: str, attrib_value: str):
        """ Set a value in specific attribute of an element in the page

        Args:
            selector (str): CSS selector of the element
            attrib_name (str): name of the html attribute
            attrib_value (str): value to set in the attribute
        """
        
        elem = self.driver.find_element(By.CSS_SELECTOR, selector)
        self.driver.execute_script(
            f"arguments[0].setAttribute('{attrib_name}', '{attrib_value}');", elem)

    def get_attrib(self, selector: str, attrib_name: str) -> str:
        """ Return the class value from specific element in the page
        
        Args:
            selector (str): CSS selector of the element
            attrib_name (str): name of the html attribute
            
        Returns:
            str: value of the attribute
        """

        try:
            elem = self.driver.find_element(By.CSS_SELECTOR, selector)
            return elem.get_attribute(attrib_name)
        except Exception:
            return None

    def get_attribs(self, selector: str, attrib_name: str,
                    allow_duplicates: bool = True, allow_empty: bool = True) -> list:
        """ Return the attributes value from specific element in the page
        
        Args:
            selector (str): CSS selector of the element
            attrib_name (str): name of the html attribute
            allow_duplicates (bool): allow duplicate values
            allow_empty (bool): allow empty values
            
        Returns:
            list: list of values of the attribute
        """

        attributes = []
        elems = self.driver.find_elements(By.CSS_SELECTOR, selector)

        for elem in elems:

            try:
                attribute = elem.get_attribute(attrib_name)

                # Skip duplicates in not duplicate mode
                if not allow_duplicates and attribute in attributes:
                    continue

                # Skip empty results in not ampty mode
                if not allow_empty and attribute.strip() == "":
                    continue

                attributes.append(attribute)

            except Exception:
                continue

        return attributes

    def get_elem(self, selector: str) -> WebElement:
        """ Return an specific element in the page
        
        Args:
            selector (str): CSS selector of the element
            
        Returns:
            WebElement: element in the page
        """

        elem = self.driver.find_element(By.CSS_SELECTOR, selector)
        return elem

    def get_elems(self, selector: str) -> list:
        """ Return a list of specific element in the page
        
        Args:
            selector (str): CSS selector of the elements
            
        Returns:
            list: list of elements in the page
        """

        elems = self.driver.find_elements(By.CSS_SELECTOR, selector)
        return elems

    def set_page_js(self, web_page: str, new_tab: bool = False):
        """ Open page with js, in current or new tab
        
        Args:
            web_page (str): url of the page
            new_tab (bool): open in new tab
        """

        self.__web_page__ = web_page

        if new_tab:
            script = f'window.open("{web_page}");'
        else:
            script = f'window.open("{web_page}").focus();'

        print(script)

        self.driver.execute_script(script)

    def set_page(self, web_page: str, time_out: int = 0, break_time_out: bool = False):
        """ Update the web page in browser
        
        Args:
            web_page (str): url of the page
            time_out (int): time to wait
            break_time_out (bool): break if time out
        """

        try:

            self.__web_page__ = web_page

            # Save time out when is greader than 0
            if time_out > 0:
                self.driver.set_page_load_timeout(time_out)

            self.driver.get(self.__web_page__)

        # Catch error in load page
        except Exception:

            # Raise error
            if break_time_out:
                raise Exception(f"Time out to load page: {web_page}")

            # Ignore error
            else:
                self.driver.execute_script("window.stop();")

    def click_js(self, selector: str):
        """ Send click with js, for hiden elements
        
        Args:
            selector (str): CSS selector of the element
        """
        
        elem = self.driver.find_element(By.CSS_SELECTOR, selector)
        self.driver.execute_script("arguments[0].click();", elem)

    def select_drop_down_index(self, selector: str, index: int):
        """ Select specific elemet (with number) in a drop down elemet
        
        Args:
            selector (str): CSS selector of the element
            index (int): index of the element
        """

        select_elem = Select(self.get_elem(selector))
        select_elem.select_by_index(index)

    def select_drop_down_text(self, selector: str, text: str):
        """ Select a value in a drop down eleme (Select elem)
        
        Args:
            selector (str): CSS selector of the element
            text (str): text of the element
        """

        select_elem = Select(self.get_elem(selector))
        select_elem.select_by_visible_text(text)

    def go_bottom(self, selector: str = "body"):
        """ Go to the end of the page, sending keys
        
        Args:
            selector (str): CSS selector of the element
        """

        elem = self.driver.find_element(By.CSS_SELECTOR, selector)
        elem.send_keys(Keys.CONTROL + Keys.END)

    def go_top(self, selector: str = "body"):
        """ Go to the start of the page, sending keys
        
        Args:
            selector (str): CSS selector of the element
        """

        elem = self.driver.find_element(By.CSS_SELECTOR, selector)
        elem.send_keys(Keys.CONTROL + Keys.UP)

    def go_down(self, selector: str = "body"):
        """ Advance to down, in the page, sending keys
        
        Args:
            selector (str): CSS selector of the element
        """

        elem = self.driver.find_element(By.CSS_SELECTOR, selector)
        elem.send_keys(Keys.PAGE_DOWN)

    def go_up(self, selector: str = "body"):
        """ Return to up, in page, sending keys
        
        Args:
            selector (str): CSS selector of the element
        """

        elem = self.driver.find_element(By.CSS_SELECTOR, selector)
        elem.send_keys(Keys.PAGE_UP)

    def switch_to_main_frame(self):
        """ Switch to the main contecnt of the page
        """

        self.driver.switch_to.default_content()

    def switch_to_frame(self, frame_selector: str):
        """ Switch to iframe inside the main content
        
        Args:
            frame_selector (str): CSS selector of the element
        """

        frame = self.get_elem(frame_selector)
        self.driver.switch_to.frame(frame)

    def open_tab(self):
        """ Create new empty tab in browser
        """

        self.driver.execute_script("window.open('');")

    def close_tab(self):
        """ Clase the current tab in the browser
        """

        self.driver.close()

    def switch_to_tab(self, index: int):
        """ Switch to specific number of tab
        
        Args:
            index (int): number of the tab
        """

        windows = self.driver.window_handles
        self.driver.switch_to.window(windows[index])

    def refresh_selenium(self, time_units: int = 1, back_tab: int = 0):
        """ Refresh the selenium data, creating and closing a new tab
        
        Args:
            time_units (int): time to wait
            back_tab (int): tab to return after refresh
        """

        # Open new tab and go to it
        self.open_tab()
        self.switch_to_tab(len(self.driver.window_handles) - 1)

        # Wait time
        time.sleep(self.basetime * time_units)

        # Close new tab and return to specific tab
        self.close_tab()
        self.switch_to_tab(back_tab)

        # Wait time
        time.sleep(self.basetime * time_units)

    def save_page(self, file_html: os.path):
        """ Save current page in local file
        
        Args:
            file_html (os.path): path to save the html file
        """
        
        page_html = self.driver.page_source
        current_folder = os.path.dirname(__file__)
        page_file = open(os.path.join(
            current_folder, file_html), "w", encoding='utf-8')
        page_file.write(page_html)
        page_file.close()

    def zoom(self, percentage: int = 50):
        """ Custom page zoom with JS
        
        Args:
            percentage (int): percentage of the zoom
        """

        script = f"document.body.style.zoom='{percentage}%'"
        self.driver.execute_script(script)

    def kill(self):
        """ Detect and close all tabs """
        tabs = self.driver.window_handles
        for _ in tabs:
            self.switch_to_tab(0)
            self.end_browser()

    def scroll(self, selector: str, scroll_x: int, scroll_y: int):
        """ Scroll X or Y in specific element of the page
        
        Args:
            selector (str): CSS selector of the element
            scroll_x (int): number of pixels to scroll in X
            scroll_y (int): number of pixels to scroll in Y
        """

        elem = self.get_elem(selector)
        self.driver.execute_script("arguments[0].scrollTo(arguments[1], arguments[2])",
                                   elem,
                                   scroll_x,
                                   scroll_y)

    def set_local_storage(self, key: str, value: str):
        """ Set a value in local storage with js

        Args:
            key (str): local storage key
            value (str): local storage value
        """
        
        script = f"window.localStorage.setItem('{key}', '{value}')"
        self.driver.execute_script(script)
        
    def delete_comments_js(self, selector: str = 'body'):
        """ Delete html comments with js
        
        Args:
            selector: CSS selector of the element. Default is 'body'
        """
        
        script = """
        // Function to remove all comment nodes
        function removeComments(node) {
            // Loop through all child nodes
            for (let i = node.childNodes.length - 1; i >= 0; i--) {
                const child = node.childNodes[i];
                // If it's a comment node (nodeType 8), remove it
                if (child.nodeType === 8) {
                    node.removeChild(child);
                } else if (child.nodeType === 1) {
                    // If it's an element node (nodeType 1),
                    // recursively check its children
                    removeComments(child);
                }
            }
        }

        // Start the removal process from the document body
        const cssSelector = '{selector}'
        const elem = document.querySelector(cssSelector)
        removeComments(elem);
        """.replace('{selector}', selector)
        
        self.driver.execute_script(script)